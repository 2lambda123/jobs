Module jobs_app
===============


<h1>Module jobs_app</h1>

* [Description](#description)
* [Function Index](#index)
* [Function Details](#functions)


Application module for JOBS.



<h2><a name="description">Description</a></h2>



  Normally, JOBS is configured at startup, using a static configuration.
There is a reconfiguration API [`jobs`](jobs.md), which is mainly for evolution  
of the system.



<h3><a name="Configuring_JOBS">Configuring JOBS</a></h3>




A static configuration can be provided via application environment
variables for the `jobs` application. The following is a list of  
recognised configuration parameters.



<h4><a name="{config,_Filename}">{config, Filename}</a></h4>




Evaluate a file using [`//kernel/file:script/1`](/Users/uwiger/ETC/git/kernel/doc/file.md#script-1), treating the data  
returned from the script as a list of configuration options.



<h4><a name="{queues,_QueueOptions}">{queues, QueueOptions}</a></h4>




Configure a list of queues according to the provided QueueOptions.
If no queues are specified, a queue named `default` will be created  
with default characteristics.



Below are the different queue configuration options:


<h5>
<a name="{Name,_Options}">{Name, Options}</a>
</h5>



This is the generic queue configuration pattern.
`Name :: any()` is used to identify the queue.



Options:



`{mod, Module::atom()}` provides the name of the queueing module.
The default module is `jobs_queue`.



`{type, fifo | lifo | {producer, F}}` specifies the semantics of the
queue. Note that the specified queue module may be limited to only one
type (e.g. the `jobs_queue_list` module only supports `lifo` semantics).
If the type is `{producer, F}`,



`{max_time, integer() | undefined}` specifies the longest time that a job
request may spend in the queue. If `undefined`, no limit is imposed.



`{max_size, integer() | undefined}` specifies the maximum length (number  
of job requests) of the queue. If the queue has reached the maximum length,  
subsequent job requests will be rejected unless it is possible to remove  
enough requests that have exceeded the maximum allowed time in the queue.



`


<h5>
<a name="{Name,_standard_rate,_R}">{Name, standard_rate, R}</a>
</h5>



A simple rate-regulated queue with throughput rate `R`, and basic cpu- and  
memory-related feedback compensation.


<h5>
<a name="{Name,_standard_counter,_N}">{Name, standard_counter, N}</a>
</h5>



A simple counter-regulated queue, giving each job a weight of 1, and thus
allowing at most `N` jobs to execute concurrently. Basic cpu- and memory-  
related feedback compensation.


<h5>
<a name="{Name,_producer,_F,_Options}">{Name, producer, F, Options}</a>
</h5>

A producer queue is not open for incoming jobs, but will rather initiate
jobs at the given rate.

<h2><a name="index">Function Index</a></h2>



<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#init-1">init/1</a></td><td></td></tr><tr><td valign="top"><a href="#start-2">start/2</a></td><td></td></tr><tr><td valign="top"><a href="#stop-1">stop/1</a></td><td></td></tr></table>


<a name="functions"></a>


<h2>Function Details</h2>


<a name="init-1"></a>


<h3>init/1</h3>





`init(X1) -> any()`


<a name="start-2"></a>


<h3>start/2</h3>





`start(X1, X2) -> any()`


<a name="stop-1"></a>


<h3>stop/1</h3>





`stop(X1) -> any()`



_Generated by EDoc, Nov 5 2010, 09:05:03._